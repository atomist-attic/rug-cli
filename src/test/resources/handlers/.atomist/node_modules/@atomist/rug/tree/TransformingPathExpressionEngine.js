"use strict";
/**
 * Convenient superclass that wraps an existing PathExpressionEngine
 * to decorate every returned node. Also adds convenience methods.
 */
var TransformingPathExpressionEngine = (function () {
    function TransformingPathExpressionEngine(delegate, nodeTransform) {
        this.delegate = delegate;
        this.nodeTransform = nodeTransform;
    }
    TransformingPathExpressionEngine.prototype.addType = function (dt) {
        this.delegate = this.delegate.addType(dt);
        return this;
    };
    // Unfortunately other calls don't go through this,
    // because they're in Scala
    TransformingPathExpressionEngine.prototype.evaluate = function (root, expr) {
        var m1 = this.delegate.evaluate(root, expr);
        var m2 = {
            root: function () { return this.nodeTransform(m1.root()); },
            matches: function () {
                var _this = this;
                return m1.matches().map(function (n) { return _this.nodeTransform(n); });
            }
        };
        return m2;
    };
    TransformingPathExpressionEngine.prototype.with = function (root, expr, f) {
        var _this = this;
        this.delegate.with(root, expr, function (n) {
            //console.log("Intercepted with")
            var transformed = _this.nodeTransform(n);
            //console.log(`Transformed is ${transformed}`)
            f(transformed);
        });
    };
    TransformingPathExpressionEngine.prototype.scalar = function (root, expr) {
        return this.nodeTransform(this.delegate.scalar(root, expr));
    };
    TransformingPathExpressionEngine.prototype.as = function (root, name) {
        return this.nodeTransform(this.delegate.as(root, name));
    };
    // Find the children of the current node of this time
    TransformingPathExpressionEngine.prototype.children = function (root, name) {
        var _this = this;
        return this.delegate.children(root, name)
            .map(function (n) { return _this.nodeTransform(n); });
    };
    //-------------------------------------------------------------
    // Additional convenience methods
    //-------------------------------------------------------------
    TransformingPathExpressionEngine.prototype.withExpression = function (root, pe, f) {
        this.with(root, pe.expression, f);
    };
    return TransformingPathExpressionEngine;
}());
exports.TransformingPathExpressionEngine = TransformingPathExpressionEngine;
