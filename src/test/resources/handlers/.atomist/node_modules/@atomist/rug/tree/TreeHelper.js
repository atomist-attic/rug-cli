"use strict";
/**
 * Helper functions for working with TreeNodes in simple
 * cases where we don't need a path expression.
 */
var TreeHelper = (function () {
    function TreeHelper() {
    }
    TreeHelper.prototype.findPathFromAncestor = function (n, nodeTest) {
        var parent = n.parent(); // Makes checking for parent function later easy
        if (parent == null) {
            // We couldn't resolve the path
            return null;
        }
        else if (nodeTest(parent)) {
            //console.log(`Gotcha: Parent is ${parent}`)
            // TODO what if it's not unique - need position, but then parent.children may reinitalize.
            // Not if a mutable container, admittedly
            return "/" + n.nodeName();
        }
        else if (parent.parent()) {
            return this.findPathFromAncestor(parent, nodeTest) + ("/" + n.nodeName());
        }
        else
            return null;
    };
    TreeHelper.prototype.findPathFromAncestorWithTag = function (n, tag) {
        var r = this.findPathFromAncestor(n, function (n) { return n.nodeTags().contains(tag); });
        return r;
    };
    /**
     * Return an ancestor meeting the given criteria
     * or null if it cannot be found
     */
    TreeHelper.prototype.findAncestor = function (n, nodeTest) {
        var parent = n.parent(); // Makes checking for parent function later easy
        if (parent == null) {
            return null;
        }
        else if (nodeTest(parent)) {
            //console.log(`Gotcha: Parent is ${parent}`)
            return parent;
        }
        else if (parent.parent()) {
            return this.findAncestor(parent, nodeTest);
        }
        else
            return null;
    };
    /**
     * Find an ancestor with a given tag
     */
    TreeHelper.prototype.findAncestorWithTag = function (n, tag) {
        var r = this.findAncestor(n, function (n) { return n.nodeTags().contains(tag); });
        return r;
    };
    return TreeHelper;
}());
exports.TreeHelper = TreeHelper;
