/*
 * Copyright 2015-2017 Atomist Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { TreeNode, GraphNode, FormatInfo, PathExpressionEngine } from "@atomist/rug/tree/PathExpression";
import { ProjectContext } from "@atomist/rug/operations/ProjectEditor";
import { ArtifactContainer } from "./ArtifactContainer";
import { File } from "./File";
export { Project };

/*
 * Project
 */
interface Project extends ArtifactContainer {

    /**
      * Create a directory
      *
      * @param name {string} The name of the directory being added
      * @param parentPath {string} The path under which the directory should be created
      */
    addDirectory(name: string, parentPath: string): void;

    /**
      * Create a directory
      *
      * @param directoryPath {string} The path under which the directory and any missing intermediate directories will be created
      */
    addDirectoryAndIntermediates(directoryPath: string): void;

    /**
      * Add the given executable file to the project. Path can contain /s. Content is a literal string
      *
      * @param path {string} The path to use
      * @param content {string} The content to be placed in the new file
      */
    addExecutableFile(path: string, content: string): void;

    /**
      * Add the given file to the project. Path can contain /s. Content is a literal string
      *
      * @param path {string} The path to use
      * @param content {string} The content to be placed in the new file
      */
    addFile(path: string, content: string): void;

    /**
      * Return a new Project View based on the original backing object (normally the .atomist/ directory)
      *
      * @returns {Project}
      */
    backingArchiveProject(): Project;

    /**
      * Provides access additional context, such as the PathExpressionEngine
      *
      * @returns {ProjectContext}
      */
    context(): ProjectContext;

    /**
      * Copy the given file from the editor's backing archive to the same path in project being edited. Fail the editor if it isn't found or if the destination already exists
      *
      * @param sourcePath {string} Source path
      */
    copyEditorBackingFileOrFail(sourcePath: string): void;

    /**
      * Copy the given file from the editor's backing archive. Fail the editor if it isn't found or if the destination already exists
      *
      * @param sourcePath {string} Source path
      * @param destinationPath {string} Destination path
      */
    copyEditorBackingFileOrFailToDestination(sourcePath: string, destinationPath: string): void;

    /**
      * Copy the given file from the editor's backing archive. Fail the editor if it isn't found or if the destination already exists
      *
      * @param sourcePath {string} Source directory
      * @param destinationPath {string} Destination path
      */
    copyEditorBackingFilesOrFail(sourcePath: string, destinationPath: string): void;

    /**
      * Copy the given files from the editor's backing archive under the given directory into the same directory in the project being edited.
      *
      * @param sourcePath {string} Source directory
      */
    copyEditorBackingFilesPreservingPath(sourcePath: string): void;

    /**
      * Copy the given files from the editor's backing archive under the given path. Take the relative paths and place under new destination path
      *
      * @param sourcePath {string} Source directory
      * @param destinationPath {string} Destination path
      */
    copyEditorBackingFilesWithNewRelativePath(sourcePath: string, destinationPath: string): void;

    /**
      * Copy the given file in the target project. It is not an error if it doesn't exist
      *
      * @param sourcePath {string} Source path
      * @param destinationPath {string} Destination path
      */
    copyFile(sourcePath: string, destinationPath: string): void;

    /**
      * Copy the given file in the target project. Fail the editor if it isn't found or if the destination already exists
      *
      * @param sourcePath {string} Source path
      * @param destinationPath {string} Destination path
      */
    copyFileOrFail(sourcePath: string, destinationPath: string): void;

    /**
      * The number of files directly in this directory
      *
      * @param path {string} The path to use
      * @returns {number}
      */
    countFilesInDirectory(path: string): number;

    /**
      * Deletes a directory with the given path
      *
      * @param path {string} The path to use
      */
    deleteDirectory(path: string): void;

    /**
      * Delete the given file from the project. Path can contain /s.
      *
      * @param path {string} The path to use
      */
    deleteFile(path: string): void;

    /**
      * Describe a change we made to this object
      *
      * @param arg0 {string} 
      */
    describeChange(arg0: string): void;

    /**
      * Edit with the given editor
      *
      * @param editorName {string} Name of the editor to invoke
      * @param params {any} Parameters to pass to the editor
      */
    editWith(editorName: string, params: any): void;

    /**
      * Does a file with the given path exist and have the expected content?
      *
      * @param path {string} The path to use
      * @param content {string} The content to check
      * @returns {boolean}
      */
    fileContains(path: string, content: string): boolean;

    /**
      * The total number of files in this project
      *
      * @returns {number}
      */
    fileCount(): number;

    /**
      * Does a file with the given path exist and have the expected content?
      *
      * @param path {string} The path to use
      * @param content {string} The content to check against the given file
      * @returns {boolean}
      */
    fileHasContent(path: string, content: string): boolean;

    /**
      * Files in this archive
      *
      * @returns {File[]}
      */
    files(): File[];

    /**
      * Makes a file executable
      *
      * @param path {string} The path to use
      */
    makeExecutable(path: string): void;

    /**
      * Merge the given template to the given output path.
      *
      * @param template {string} The name of the template within the backing Rug archive, under /.atomist / templates
      * @param path {string} The path that will be the merged path within the output project.
      * @param parameters {any} Parameters
      */
    merge(template: string, path: string, parameters: any): void;

    /**
      * Merge templates from the specified directory in the backing archive, under /.atomist/templates, to the given output path in the project being edited.
      *
      * @param templatesPath {string} Source template path where content will be used to merge into target project
      * @param outputPath {string} The destination path within the destination project
      * @param ic {any} Parameters to the template
      */
    mergeTemplates(templatesPath: string, outputPath: string, ic: any): void;

    /**
      * Move the contents of this project under the given path, preserving its present path under that
      *
      * @param path {string} The root path to move the file to
      */
    moveUnder(path: string): void;

    /**
      * Return the name of the project. If it's in GitHub, it will be the repo name. If it's on the local filesystem it will be the directory name
      *
      * @returns {string}
      */
    name(): string;

    /**
      * Return the path expression to this point in the given file
      *
      * @param arg0 {string} 
      * @param arg1 {string} 
      * @param arg2 {number} 
      * @param arg3 {number} 
      * @returns {string}
      */
    pathTo(arg0: string, arg1: string, arg2: number, arg3: number): string;

    /**
      * Don't use. Merely intended to simplify the life of the Rug to TypeScript transpiler.
      *
      * @returns {Project[]}
      */
    projects(): Project[];

    /**
      * Replace all occurrences of the given regular expression in this project
      *
      * @param regexp {string} The regular expression to search for
      * @param replacement {string} The string to replace matches with
      */
    regexpReplace(regexp: string, replacement: string): void;

    /**
      * Replace all occurrences of the given string literal in this project. Use with care!
      *
      * @param literal {string} The string to look for
      * @param replaceWith {string} The string to replace matches with
      */
    replace(literal: string, replaceWith: string): void;

    /**
      * Globally replace all occurrences of the given string literal in file paths in this project
      *
      * @param literal {string} The string to search for
      * @param replacement {string} The string to replace in the paths if found
      */
    replaceInPath(literal: string, replacement: string): void;

    /**
      * Node content
      *
      * @returns {string}
      */
    value(): string;

}   

