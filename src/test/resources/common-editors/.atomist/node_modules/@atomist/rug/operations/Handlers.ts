import {GraphNode, TreeNode, PathExpressionEngine, PathExpression, Match} from "../tree/PathExpression"
import {Parameter} from "./RugOperation"

interface RugCoordinate {
  readonly name: string
  readonly group: string
  readonly artifact: string
}

type InstructionKind = "generate" | "edit" | "review" | "execute" | "respond" | "command"

interface Instruction<T extends InstructionKind> {
  readonly name: string | RugCoordinate
  readonly parameters?: {}
  readonly kind: T
}

interface Plannable {}

class Respondable<T extends Review | Edit | Generate | Execute> implements Plannable {
  instruction: T
  onSuccess?: Plan | Message | Respond
  onError?: Plan | Message | Respond
}

class NonRespondable<T extends Command | Respond> implements Plannable {
  instruction: T
}

class Presentable<T extends InstructionKind> {
  instruction: Instruction<T> | PresentableGenerate | PresentableEdit | PresentableReview
  label?: string
}

// Location to a project.
// in the future, we could add things like github urls, orgs etc.
interface ProjectReference {

}

interface ProjectInstruction<T extends InstructionKind> extends Instruction<T> {
  project: string | ProjectReference
}

interface Review extends ProjectInstruction<"review"> {

}

interface Edit extends ProjectInstruction <"edit">{

}

//extends ProjectInstruction because we need to know the project name
interface Generate extends ProjectInstruction <"generate"> {

}

//because in a message, we may not know project name yet
interface PresentableGenerate extends Instruction<"generate"> {
    project?: string | ProjectReference
}

//because in a message, we may not know project name yet
interface PresentableEdit extends Instruction<"edit"> {
    project?: string | ProjectReference
}

//because in a message, we may not know project name yet
interface PresentableReview extends Instruction<"review"> {
    project?: string | ProjectReference
}

interface Execute extends Instruction<"execute"> {
}

interface Command extends Instruction<"command"> {

}

interface Respond extends Instruction<"respond"> {

}

interface HandleCommand {
  handle(ctx: HandlerContext): Plan
}

interface HandleEvent<R extends GraphNode, M extends GraphNode> {
  handle(root: Match<R,M>): Plan
}

interface HandleResponse<T>{
  handle(response: Response<T>): Plan
}

/**
 * Context available to all handlers. Unique to a team.
 * Exposes a context root from which queries can be run,
 * using the given PathExpressionEngine
 */
interface HandlerContext {

  /**
   * Id of the team we're working on behalf of
   */
  teamId: string

  pathExpressionEngine: PathExpressionEngine

  /**
   * The root of this team's context. Allows execution
   * of path expressions.
   */
  contextRoot: GraphNode
}

enum Status {
  failure,
  success
}

interface Response<T> {

    msg(): string

    code(): number

    status(): Status

    body(): T
}

/**
 * A bunch of stuff to do asynchronously
 * Messages got to the bot.
 * Rugs are run straight away
 */
class Plan {

   messages: Message[] = [];

   instructions: Plannable[] = [];

   public add?(thing: Plannable | Message): this {
     if(thing instanceof Message){
       this.messages.push(thing)
     }
     else {
        this.instructions.push(thing)
     }
     return this;
   }

   static ofMessage(m: Message): Plan {
     return new Plan().add(m);
   }
}

/**
 * Represents a Message to the bot.
 * Any rugs can contain unbound parameters, and the bot will try to fill them out
*/
class Message {

  body: string;
  channelId?: string;
  instructions?: Presentable<any>[] = [];

  node?: GraphNode;
  correlationId?: string

  public withCorrelationId?(id: string) : this {
    this.correlationId = id;
    return this;
  }

  public withNode?(node: GraphNode) : this {
    this.node = node;
    return this;
  }

  public withChannelId?(chid: string) : this {
    this.channelId = chid;
    return this;
  }

  constructor(about?: string){
    this.body = about;
  }

  public addAction?(instruction: Presentable<any>): this {
    this.instructions.push(instruction)
    return this;
  }
}

abstract class MappedParameters {
  static readonly GITHUB_REPO_OWNER: string = "atomist://github/repository/owner"
  static readonly GITHUB_REPOSITORY: string = "atomist://github/repository"
  static readonly SLACK_CHANNEL: string = "atomist://slack/channel"
  static readonly SLACK_TEAM: string = "atomist://slack/team"
  static readonly SLACK_USER: string = "atomist://slack/user"
  static readonly GITHUB_WEBHOOK_URL: string = "atomist://github_webhook_url"
}

export {MappedParameters}
export {Respond, Presentable, NonRespondable, Respondable, Instruction, Response, HandlerContext, Plan, Message, Execute}
export {HandleResponse, HandleCommand, HandleEvent}
export {Edit, ProjectInstruction}
