/**
 * Module containing Scala types.
 * Interfaces with "Nav" suffix have 1:1 mapping to grammar productions
 * (with upper camel case).
 * They are purely a convenience for TypeScript users: Can be ignored in JavaScript.
 * Ultimately, such interfaces can be generated.
 *
 * Classes with "Ops" suffix are additional operations.
 */
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var TextTreeNodeOps_1 = require("../TextTreeNodeOps");
var SourceOps = (function (_super) {
    __extends(SourceOps, _super);
    function SourceOps() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Return package name or null
     */
    SourceOps.prototype.packageName = function () {
        try {
            return this.pexe.scalarStr(this.node, "/pkg/termSelect");
        }
        catch (e) {
            return null;
        }
    };
    /**
     * Add the given import if it's not already imported
     */
    SourceOps.prototype.addImport = function (newImport) {
        var fullNewImport = "import " + newImport;
        if (this.node.value().indexOf(fullNewImport) == -1) {
            var pkg = this.packageName();
            if (pkg)
                pkg.update(pkg.value() + "\n\n" + fullNewImport);
            else {
                // Not in a package. Just put at the top of the class
                this.prepend(fullNewImport + "\n\n");
            }
        }
    };
    return SourceOps;
}(TextTreeNodeOps_1.TextTreeNodeOps));
exports.SourceOps = SourceOps;
var DefnClassOps = (function (_super) {
    __extends(DefnClassOps, _super);
    function DefnClassOps() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Add this content to the beginning of the body
     */
    DefnClassOps.prototype.addToStartOfBody = function (what) {
        // TODO what if type body is empty?
        var firstStatement = this.node.template().children()[0];
        firstStatement.update(what + "\n\n" + firstStatement.value());
    };
    return DefnClassOps;
}(TextTreeNodeOps_1.TextTreeNodeOps));
exports.DefnClassOps = DefnClassOps;
var TermApplyOps = (function (_super) {
    __extends(TermApplyOps, _super);
    function TermApplyOps() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return TermApplyOps;
}(TextTreeNodeOps_1.TextTreeNodeOps));
exports.TermApplyOps = TermApplyOps;
var TermApplyInfixOps = (function (_super) {
    __extends(TermApplyInfixOps, _super);
    function TermApplyInfixOps() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    TermApplyInfixOps.prototype.reverseShould = function () {
        //console.log(`Containing file=${this.containingFile()}`)
        var termSelect = this.node.termSelect();
        var termApply = this.node.termApply();
        if (termApply != null && ["be", "equal"].indexOf(termApply.termName().value()) > -1) {
            var newValue = "assert(" + termSelect.value() + " === " + termApply.children()[1].value() + ")";
            //console.log(`Replacing [${shouldTerm.value()}] with [${newValue}]`)
            this.node.update(newValue);
        }
    };
    return TermApplyInfixOps;
}(TextTreeNodeOps_1.TextTreeNodeOps));
exports.TermApplyInfixOps = TermApplyInfixOps;
