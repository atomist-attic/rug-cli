/**
 * Helper functions for working with TreeNodes in simple
 * cases where we don't need a path expression.
 */
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function hasTag(n, t) {
    return n.nodeTags().indexOf(t) > -1;
}
exports.hasTag = hasTag;
function findPathFromAncestor(n, nodeTest) {
    var parent = n.parent(); // Makes checking for parent function later easy
    if (parent == null) {
        // We couldn't resolve the path
        return null;
    }
    else if (nodeTest(parent)) {
        //console.log(`Gotcha: Parent is ${parent}`)
        // TODO what if it's not unique - need position, but then parent.children may reinitialize.
        // Not if a mutable container, admittedly
        return "/" + n.nodeName();
    }
    else if (parent.parent()) {
        return findPathFromAncestor(parent, nodeTest) + ("/" + n.nodeName());
    }
    else
        return null;
}
exports.findPathFromAncestor = findPathFromAncestor;
function findPathFromAncestorWithTag(n, tag) {
    var r = findPathFromAncestor(n, function (n) { return n.nodeTags().contains(tag); });
    return r;
}
exports.findPathFromAncestorWithTag = findPathFromAncestorWithTag;
/**
 * Return an ancestor meeting the given criteria
 * or null if it cannot be found
 */
function findAncestor(n, nodeTest) {
    var parent = n.parent(); // Makes checking for parent function later easy
    if (parent == null) {
        return null;
    }
    else if (nodeTest(parent)) {
        //console.log(`Gotcha: Parent is ${parent}`)
        return parent;
    }
    else if (parent.parent()) {
        return findAncestor(parent, nodeTest);
    }
    else
        return null;
}
exports.findAncestor = findAncestor;
/**
 * Find an ancestor with a given tag
 */
function findAncestorWithTag(n, tag) {
    var r = findAncestor(n, function (n) { return n.nodeTags().indexOf(tag) != -1; });
    return r;
}
exports.findAncestorWithTag = findAncestorWithTag;
